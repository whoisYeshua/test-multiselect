import React from 'react';
import { ScreenWidthShortcut, ScreenWidthShortcutWithUnknown } from '@ui/screen-size-provider';
import { TooltipProps } from '../../accessories/Tooltip/Tooltip';
import { ControlBoxSize } from './styled/ControlBox';
import { ControlBoxSizeType } from './types';
/**
 * Набор свойств, характерный для всех контролов, использующих ControlWrapper или BasicControlWrapper
 * Доступен всем контролам библиотеки для наследования и расширения.
 */
export interface ControlProps {
    /**
     * Идентификатор контрола в рамках формы/виджета, обязателен для работы синхронизации.
     */
    name: string;
    /**
     * Видимость. Определяет, отображается ли контрол в разметке.
     */
    hidden?: boolean;
    /**
     * Активность. Определяет, доступно ли редактирование.
     */
    disabled?: boolean;
    /**
     * Активность во время синхронизации. Определяет блокировку контрола и отображение лоадера.
     */
    locked?: boolean;
    /**
     * Отображаемое название контрола.
     */
    caption?: string;
    /**
     * Идентификатор контрола в HTML разметке документа. Обычно применяется в качестве селектора.
     * Должен быть уникальным. Применяется на внешний родительский элемент всего контрола.
     * Для доступа к внутренним элементам по селекторам, необходимо учитывать вложенность, относительно `id`.
     * Если не указан, генерируется автоматически на основе `name`.
     */
    id?: string;
    /**
     * Дополнительные классы для контрола (оболочки). Нужны для кастомизации стилей или селекторов для UI тестов.
     */
    className?: string;
    /**
     * Массив ошибок валидации, которые необходимо отобразить.
     * Избегать <a href="/?path=/story/design-system-справочник-ссылочный-тип--docs">прямой передачи массива</a>
     */
    errors?: string[] | string | null;
    /**
     * Иконка ошибки. Отображается перед текстом ошибки.
     */
    errorIcon?: React.ReactNode;
    /**
     * Подсказка под полем ввода. При наличии ошибок, они отображаются вместо неё и перекрывают переданный текст.
     * Можно использовать для вывода дополнительной информации.
     */
    hint?: React.ReactNode;
    /**
     * Тултип в контроле.
     * Если в контроле есть кнопка, то тогда рендерится вместо нее.
     * При наведении на иконку вопроса показывает в доступном пространстве подсказку.
     */
    tooltip?: string;
    /**
     * Вариант внешнего вида иконки тултипа (с заливкой фона или без неё)
     */
    tooltipIconVariant?: TooltipProps['iconVariant'];
    /**
     * Позволяет открыть тултип при помощи внешнего параметра.
     * При наведении на тултип и потере ховера он закроется как обычно и
     * для повторного открытия необходимо будет снова изменить параметр.
     */
    showTooltip?: boolean;
    /**
     * Обработчик клика по иконке тултипа в контроле.
     * Возвращает все параметры тултипа, позволяя их обработать.
     * ВНИМАНИЕ! Даже при указании обработчика,
     * тултип автоматически отображается/скрывается при наведении/удалении курсора:
     * обработка клика позволяет расширить функциональность тултипа, но не заменяет стандартную.
     */
    onTooltipClick?: (props: TooltipProps) => void;
}
/**
 * Набор свойств ControlWrapper'а, которые могут быть
 * унаследованы контролами и использовать в качестве пропсов у них.
 */
export interface ExternalControlWrapperProps extends Omit<ControlProps, 'caption'> {
    /**
     * Отображаемое название контрола.
     */
    caption: string;
    /**
     * Размер "рамки" контрола.
     * Именно такие варианты размера использованы для соответствия по высоте компоненту `Button`.
     * При использовании размера `XS`, заголовок становится не обязательным,
     * так как анимация заголовка не применяется в уменьшенной рамке.
     * Если заголовок указан, он выносится за пределы рамки контрола.
     * Размер `L` - поведение по умолчанию, с плавающим заголовком, заголовок обязателен при использовании размера `L`.
     */
    size?: ControlBoxSizeType;
    /**
     * Позволяет применить стили статуса для контрола.
     * Если указан, окрашивает рамку контрола в соответствующий цвет.
     * НЕ СБРАСЫВАЕТСЯ АВТОМАТИЧЕСКИ ПРИ ФОКУСЕ! Если необходимо убрать статус по фокусу,
     * нужно удалять соответствующий параметр при срабатывании обработчика `onEditStart`.
     */
    status?: 'success' | 'warning' | 'error' | null;
    /**
     * Если указан, применяется автоскролл контрола при фокусе для указанного breakpoint и ниже.
     * `mobile` - скролл будет работать только на мобильных разрешениях,
     * `tablet` - на мобильных и планшетных,
     * `desktop` - на всех.
     * По умолчанию пытается скроллить до `0`, если указан `scrollTopOffset`, учитывает указанный сверху отступ.
     * Если от текущего положения контрола до низа страницы недостаточно места,
     * скролл сработает только до конца возможной прокрутки, это необходимо учитывать при проектировании интерфейса.
     */
    scrollTopBreakpoint?: ScreenWidthShortcut;
    /**
     * Применяется в связке с `scrollTopBreakpoint` и позволяет указать отступ сверху для скролла,
     * например, если есть фиксированная панель сверху, чтобы контрол не уехал за неё,
     * рекомендуется указать отступ как минимум на высоту панели.
     */
    scrollTopOffset?: number;
    /**
     * Разрешение экрана в виде строкового тега. Передается автоматически из контекста размера экрана.
     */
    screenWidthShortcut?: ScreenWidthShortcutWithUnknown;
}
export interface ControlWithCustomButtonProps extends ExternalControlWrapperProps {
    /**
     * Дополнительная кнопка в контроле. Только компонент Button с типом `control-icon`.
     * Может содержать исключительно иконку.
     * Клик по кнопке должен быть обработан за пределами контрола.
     * Использовать с осторожностью, учитывать ширину кнопки и доступную область внутри контрола.
     */
    button?: React.ReactNode;
}
/**
 * Набор свойств ControlWrapper'а, которые используются только внутри контролов и недоступны снаружи.
 */
export interface ControlWrapperProps extends ControlWithCustomButtonProps {
    /**
     * Имеется ли фокус на контроле. Влияет на некоторые стили.
     */
    focus?: boolean;
    /**
     * Есть ли записанное значение в дочернем элементе. Влияет на некоторые стили.
     */
    hasValue?: boolean;
    /**
     * Определяет будет ли `caption` отображаться в одну строку.
     * По умолчанию текст будет обрезан и в конце добавлено `...`.
     * Рекомендуется использовать только в компоненте `TextArea`.
     */
    multiLineCaption?: boolean;
    /**
     * Кастомизация внешнего вида курсора, в засисимости от используемого внутри компонента.
     */
    cursor?: 'default' | 'pointer' | 'text';
    /**
     * Используется ли в мульти-селекте. Влияет на некоторые стили.
     */
    isMulti?: boolean;
    /**
     * Для MultiSelect.
     * Режим, при котором выбранные опции не переносятся на другую строку, а скрываются за overflow.
     * Влияет на некоторые стили.
     */
    hideMultiLineLabels?: boolean;
    /**
     * Используется в контейнере кнопок. Влияет на расположение кнопок в контейнере. По умолчанию = 'flex-start'.
     */
    alignItems?: 'center' | 'flex-end' | 'baseline' | 'stretch' | 'flex-start';
    /**
     * Дополнительный параметр обработчика клика. Заставляет событие срабатывать
     * только если клик произошел непосредственно по контролу, а не по вложенным элементам.
     */
    strictTarget?: boolean;
    /**
     * Обработчик клика по wrapper. Можно использовать при необходимости, например, установить фокус на вложенный инпут,
     * когда клик был не по самому инпуту.
     * Не срабатывает при disabled или locked.
     */
    onClick?: (e: React.MouseEvent<HTMLDivElement>) => void;
    /**
     * Обработчик клика за пределами контрола. Срабатывает только если клик совершен по элементу,
     * который не вложен в контрол или не является частью контрола.
     */
    onOutsideClick?: (e: MouseEvent) => void;
    /**
     * Если контрол внутри - RangeInput. Влияет на некоторые стили.
     */
    isRangeInput?: boolean;
    /**
     * Указывает показывать ли кнопку для очистки значения.
     */
    showClearButton?: boolean;
    /**
     * Обработчик клика по кнопке для очистки значения.
     * Не срабатывает при disabled или locked.
     */
    handleClearButtonClick?(evt: React.MouseEvent): void;
    /**
     * Дочерний элемент, обёрнутый в контрол.
     */
    children?: React.ReactNode;
    /**
     * Ссылка на "привязанный" к контролу портал, используется в некоторых компонентах.
     * Нужна для корректной обработки `onOutsideClick`
     */
    linkedPortalRef?: React.MutableRefObject<HTMLDivElement>;
    /**
     * Применяется в крайне редких случаях, если есть несколько порталов и важно,
     * чтобы `onOutsideClick` НЕ срабатывал в каждом из них.
     * ВНИАМНИЕ! При включении данного параметра, контрол будет считать кликом внутри
     * ЛЮБОЙ клик по порталу, независимо от вложенности, так как считать взаимные зависимости
     * не представляется возможным
     */
    hasNestedPortals?: boolean;
}
export declare const ControlWrapper: React.ForwardRefExoticComponent<ControlWrapperProps & React.RefAttributes<HTMLDivElement>>;
export declare const defaultAnyControlProps: {
    disabled: boolean;
    locked: boolean;
    hidden: boolean;
    showTooltip: boolean;
    size: ControlBoxSize;
    scrollTopOffset: number;
};
declare const _default: React.ForwardRefExoticComponent<Pick<Omit<ControlWrapperProps & React.RefAttributes<HTMLDivElement>, "screenWidthShortcut" | "screenWidth" | "screenHeight">, "children" | "className" | "hidden" | "id" | "button" | "caption" | "disabled" | "onClick" | "tooltipIconVariant" | "status" | "size" | "locked" | "name" | "errors" | "errorIcon" | "hint" | "tooltip" | "showTooltip" | "onTooltipClick" | "scrollTopBreakpoint" | "scrollTopOffset" | "isMulti" | "key" | "focus" | "hasValue" | "cursor" | "onOutsideClick" | "linkedPortalRef" | "multiLineCaption" | "hideMultiLineLabels" | "alignItems" | "strictTarget" | "isRangeInput" | "showClearButton" | "handleClearButtonClick" | "hasNestedPortals"> & React.RefAttributes<React.ReactNode>>;
export default _default;
