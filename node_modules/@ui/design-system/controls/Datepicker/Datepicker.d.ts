import { ReactElement } from 'react';
import { ExternalControlWrapperProps } from '../BaseControlWrapper/ControlWrapper';
export interface RangeValue {
    startDate: string;
    endDate: string;
}
declare type DatepickerChangeValue<T extends boolean> = T extends true ? RangeValue : string;
export interface DatepickerProps<IsRange extends boolean = false> extends Omit<ExternalControlWrapperProps, 'caption'> {
    /**
     * Выбранная дата в формате ДД.ММ.ГГГГ (для режима выбора одной даты).
     */
    value?: string | null;
    /**
     * Начальная дата в формате ДД.ММ.ГГГГ (для режима range).
     */
    startDate?: string | null;
    /**
     * Конечная дата в формате ДД.ММ.ГГГГ (для режима range).
     */
    endDate?: string | null;
    /**
     * Число которое будет вычитаться из текущего года для получения минимального для выбора года.
     */
    numberOfYearsAgo?: number;
    /**
     * Число которое будет складываться с текущим годом для получения максимального для выбора года.
     */
    numberOfYearsAhead?: number;
    /**
     * Переключение в режим выбора диапазона дат, вместо одной даты (DatepickerRange)
     */
    isRange?: IsRange;
    /**
     * Недоступные для выбора даты. Можно передать массив конкретных дат в формате ДД.ММ.ГГГГ -
     * тогда недоступны будут только указанные даты.
     */
    disabledDates?: string[];
    /**
     * Самая ранняя дата из доступных для выбора. Передаётся в формате ДД.ММ.ГГГГ.
     * В совокупности с `maxDate` позволяет ограничить диапазон выбора дат.
     * Если `maxDate` не указан, то выбор ограничивается только "снизу".
     */
    minDate?: string;
    /**
     * Самая поздняя дата из доступных для выбора. Передаётся в формате ДД.ММ.ГГГГ.
     * В совокупности с `minDate` позволяет ограничить диапазон выбора дат.
     * Если `minDate` не указан, то выбор ограничивается только "сверху".
     */
    maxDate?: string;
    /**
     * Можно ли очистить выбранное значение
     */
    clearable?: boolean;
    /**
     * Отображаемое название контрола.
     */
    caption: string;
    /**
     * Позволяет указать кастомный текст сообщения о вводе некорректной или недоступной для выбора даты.
     * Для одиночного режима.
     * Валидация на такие даты работает внутри контрола.
     * Срабатывает только при вводе даты с клавиатуры,
     * так как календарь и так не позволяет выбрать запрещённые даты.
     */
    incorrectSingleDateMessage?: string;
    /**
     * Позволяет указать кастомный текст сообщения о вводе некорректной или недоступной для выбора начальной даты.
     * Для режима `range`.
     * Валидация на такие даты работает внутри контрола.
     * Срабатывает только при вводе даты с клавиатуры,
     * так как календарь и так не позволяет выбрать запрещённые даты.
     */
    incorrectStartDateMessage?: string;
    /**
     * Позволяет указать кастомный текст сообщения о вводе некорректной или недоступной для выбора конечной даты.
     * Для режима `range`.
     * Валидация на такие даты работает внутри контрола.
     * Срабатывает только при вводе даты с клавиатуры,
     * так как календарь и так не позволяет выбрать запрещённые даты.
     */
    incorrectEndDateMessage?: string;
    /**
     * Позволяет указать кастомный текст сообщения о вводе некорректного интервала.
     * Для режима `range`.
     * Срабатывает в ситуациях, если начальная дата интервала позже конечной или если интервал содержит
     * запрещённые для выбора даты.
     * Валидация на такие даты работает внутри контрола.
     * Срабатывает только при вводе даты с клавиатуры,
     * так как календарь и так не позволяет выбрать запрещённые даты.
     */
    incorrectRangeMessage?: string;
    /**
     * Позволяет открывать календарь только при клике на иконку.
     * По умолчанию календарь отображается по клику на контрол.
     */
    showCalendarOnlyOnIconClick?: boolean;
    /**
     * Обработчик изменений значения.
     */
    onChange?: (props: DatepickerProps<IsRange>, newValue: DatepickerChangeValue<IsRange>) => Promise<void> | void;
    /**
     * Обработчик события начала редактирования значения. Вызывается по фокусу.
     */
    onEditStart?: (props: DatepickerProps<IsRange>) => Promise<void> | void;
    /**
     * Обработчик события завершения редактирования значения. Вызывается после потери фокуса.
     */
    onEditEnd?: (props: DatepickerProps<IsRange>) => Promise<void> | void;
    /**
     * При использовании календаря в модальных окнах с небольшим количеством контента и, следовательно -
     * с небольшой высотой окна, календарь не помешался в окне при стандартной логике появления, в данном режиме
     * появления календаря в режиме desktop и tablet соответствует мобильной версии.
     */
    shortModalWindowMode?: boolean;
}
export declare const defaultDatepickerProps: {
    disabled: boolean;
    locked: boolean;
    hidden: boolean;
    isRange: boolean;
    showTooltip: boolean;
    incorrectSingleDateMessage: string;
    incorrectStartDateMessage: string;
    incorrectEndDateMessage: string;
    incorrectRangeMessage: string;
    clearable: boolean;
    showCalendarOnlyOnIconClick: boolean;
    shortModalWindowMode: boolean;
    scrollTopOffset: number;
    numberOfYearsAgo: number;
    numberOfYearsAhead: number;
};
export declare type DatepickerType = <IsRange extends boolean = false>(props: DatepickerProps<IsRange>) => ReactElement;
declare const _default: DatepickerType;
export default _default;
