import { SelectProps } from '../Select/Select';
import { SelectableControlItem } from '../Select/useStateManager';
interface CombinedItem extends SelectableControlItem {
    fieldName?: string;
    [key: string]: unknown;
}
declare type BaseSelectProps = Omit<SelectProps<CombinedItem, false, false>, 'async' | 'acyncSearchMessage' | 'debounceTimer' | 'searchable' | 'clearable' | 'showValueInInput' | 'onOptionsSearch' | 'optionsLoadingErrorMessage' | 'isMulti' | 'isCombined' | 'useFullItem' | 'checkboxOptions' | 'showAllSelectedLabel' | 'items' | 'optionsTitle' | 'value' | 'autoOpenNextStep' | 'notFoundMessage' | 'inputDisabled' | 'pickAllOptions'>;
export interface CombinedSelectField extends SelectProps<CombinedItem, false, false> {
    /**
     * При необходимости, дополняется любым количеством полей, помимо обязательных
     */
    [key: string]: unknown;
}
interface HideValueByCondition {
    [key: string]: (fields?: CombinedSelectField[]) => boolean;
}
export interface CombinedSelectProps extends BaseSelectProps {
    /**
     * Набор полей для выбора. Каждый из наборов обязательно должен содержать соответствующие ему `items` и `value`,
     * а также уникальный `name` для обработки выбора конкретного шага
     * и `caption` для корректного отображения имени в UI.
     * При выборе в одном из наборов, выбранный параметр сохраняется и далее выбор осуществляется
     * из следующего набора по списку.
     * Возможно динамическое обновление `items` для следующего шага, в зависимости от выбора на предыдущем.
     * Динамическое обновление должно быть реализовано на стороне приложения с использованием параметра `locked`.
     * Конкретное поле может быть скрыто для выбора при помощи свойства `hidden`,
     * в таком случае шаг выбора будет пропущен.
     */
    fields: CombinedSelectField[];
    /**
     * Позволяет скрывать некоторые поля по условию, зависящему от состояния других полей.
     * Является объектом с ключом в виде имени поля, которое должно быть скрыто
     * и со значением в виде обработчика условий для скрытия.
     * Обработчик получает в качестве аргумента все текущие поля компонента и должен вернуть `true`,
     * если поле должно быть скрыто и `false`, если не скрыто, соответственно.
     * Внутри обработчика можно смотреть на состояние других полей и в зависимости от него скрывать то,
     * для которого сей обработчик и назначен.
     * ВАЖНО!!! Скрытие по условию применяется только для визуального отображения значений поля, так что,
     * на стороне приложения по прежнему необходимо следить за корректностью логики заполнения/очистки данных полей.
     * В целях оптимизации, можно хранить данные о "скрытости" полей в стейте родительского компонента и пересчитывать
     * только по факту изменения полей. Обработчик, соответственно, должен будет просто вернуть `boolean` значение
     * из стейта.
     * <a href="/?path=/story/design-system-справочник-сложные-типы-данных-в-компонентах--docs">Сложный тип данных</a>.
     * Избегать <a href="/?path=/story/design-system-справочник-ссылочный-тип--docs">прямой передачи объектов</a>
     */
    hideValueByCondition?: HideValueByCondition;
    /**
     * Обработчик изменения значения. Вызывается для каждого из полей.
     * ВНИМАНИЕ! При удалении значения поля, если последующие значения также от него зависят,
     * необходимо удалять их на стороне приложения.
     */
    onChange?: (field: CombinedSelectField, newValue: CombinedSelectField['value']) => Promise<void> | void;
    /**
     * Обработчик события начала редактирования значения. Вызывается по фокусу для каждого из полей.
     */
    onEditStart?: (field: CombinedSelectField) => Promise<void> | void;
    /**
     * Обработчик события завершения редактирования значения. Вызывается после потери фокуса для каждого из полей.
     */
    onEditEnd?: (field: CombinedSelectField) => Promise<void> | void;
}
/**
 * Комбинированный селект.
 * Позволяет выбирать несколько значений подряд, так, что варианты на выбор
 * для следующего значения будут зависеть от выбранного предыдущего.
 */
declare const CombinedSelect: {
    ({ fields, onChange, onEditStart, onEditEnd, placeholder, creatable, hideValueByCondition, locked, ...rest }: CombinedSelectProps): JSX.Element;
    defaultProps: {
        creatable: boolean;
        disabled: boolean;
        locked: boolean;
        hidden: boolean;
        showTooltip: boolean;
        scrollTopOffset: number;
    };
    displayName: string;
};
export default CombinedSelect;
