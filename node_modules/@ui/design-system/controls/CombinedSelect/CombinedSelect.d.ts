import { ReactElement } from 'react';
import { SelectProps } from '../Select/Select';
import { SelectableControlItem } from '../Select/useStateManager';
export interface CombinedItem extends SelectableControlItem {
    fieldName?: string;
    [key: string]: unknown;
}
declare type BaseSelectProps = Omit<SelectProps<CombinedItem, false, false>, 'async' | 'acyncSearchMessage' | 'debounceTimer' | 'searchable' | 'clearable' | 'creatable' | 'showValueInInput' | 'onOptionsSearch' | 'optionsLoadingErrorMessage' | 'isMulti' | 'isCombined' | 'checkboxOptions' | 'showAllSelectedLabel' | 'items' | 'optionsTitle' | 'value' | 'autoOpenNextStep' | 'notFoundMessage' | 'inputDisabled' | 'pickAllOptions' | 'onChange' | 'onEditStart' | 'onEditEnd' | 'useFullItem' | 'defaultSearchValue'>;
declare type BaseCombinedFieldSelect = Omit<SelectProps<CombinedItem, false, false>, 'async' | 'acyncSearchMessage' | 'debounceTimer' | 'searchable' | 'clearable' | 'creatable' | 'showValueInInput' | 'onOptionsSearch' | 'optionsLoadingErrorMessage' | 'isMulti' | 'isCombined' | 'checkboxOptions' | 'showAllSelectedLabel' | 'optionsTitle' | 'autoOpenNextStep' | 'notFoundMessage' | 'inputDisabled' | 'pickAllOptions' | 'onChange' | 'onEditStart' | 'onEditEnd' | 'useFullItem'>;
export interface CombinedSelectField extends BaseCombinedFieldSelect {
    /**
     * Позволяет включить режим `creatable` для конкретных полей.
     */
    creatable?: boolean;
    /**
     * Сообщение об ошибке, при проблемах с загрузкой опций.
     * Если указано в конкретном поле, заменяет глобальное сообщение, когда данное поле активно.
     */
    optionsLoadingErrorMessage?: string;
    /**
     * При необходимости, дополняется любым количеством полей, помимо обязательных
     */
    [key: string]: unknown;
}
interface HideFieldByCondition {
    [key: string]: (fields?: CombinedSelectField[]) => boolean;
}
export declare type OnChangeValue<UseFullItem extends boolean> = UseFullItem extends true ? CombinedItem : CombinedItem['code'];
export interface CombinedSelectProps<UseFullItem extends boolean> extends BaseSelectProps {
    /**
     * Набор полей для выбора. Каждый из наборов обязательно должен содержать соответствующие ему `items` и `value`,
     * а также уникальный `name` для обработки выбора конкретного шага
     * и `caption` для корректного отображения имени в UI.
     * Если массив `items` у поля не заполнен, компонент попытается вызвать обработчик `loadOptions`,
     * с параметрами, соответствующими текущему состоянию компонента.
     * Также возможно динамическое обновление `items` для следующего шага на стороне приложения,
     * в зависимости от выбора на предыдущем, для этого необходимо использовать параметр `locked`.
     * При выборе в одном из наборов, выбранный параметр сохраняется и далее выбор осуществляется
     * из следующего набора по списку.
     * Конкретное поле может быть скрыто для выбора при помощи свойства `hidden`,
     * в таком случае шаг выбора будет пропущен.
     * <a href="/?path=/story/design-system-справочник-сложные-типы-данных-в-компонентах--docs">Сложный тип данных</a>.
     * Избегать <a href="/?path=/story/design-system-справочник-ссылочный-тип--docs">прямой передачи массива</a>
     */
    fields: CombinedSelectField[];
    /**
     * Позволяет скрывать некоторые поля по условию, зависящему от состояния других полей.
     * Является объектом с ключом в виде имени поля, которое должно быть скрыто
     * и со значением в виде обработчика условий для скрытия.
     * Обработчик получает в качестве аргумента все текущие поля компонента и должен вернуть `true`,
     * если поле должно быть скрыто и `false`, если не скрыто, соответственно.
     * Внутри обработчика можно смотреть на состояние других полей и в зависимости от него скрывать то,
     * для которого сей обработчик и назначен.
     * ВАЖНО!!! Скрытие по условию имитирует статус `hidden` у поля внутри компонента и
     * отвечает за визуальное отображение поля, однако на стороне приложения по прежнему необходимо следить за
     * корректностью логики заполнения/очистки данных полей, а также за корректной простановкой статусов,
     * если это требуется.
     * В целях оптимизации, можно хранить данные о "скрытости" полей в стейте родительского компонента и пересчитывать
     * только по факту изменения полей. Обработчик, соответственно, должен будет просто вернуть `boolean` значение
     * из стейта.
     * <a href="/?path=/story/design-system-справочник-сложные-типы-данных-в-компонентах--docs">Сложный тип данных</a>.
     * Избегать <a href="/?path=/story/design-system-справочник-ссылочный-тип--docs">прямой передачи объектов</a>
     */
    hideFieldByCondition?: HideFieldByCondition;
    /**
     * В отличие от базового `Select`, в данном случае, этот параметр определяет только значение,
     * возвращаемое в обработчике `onChange`. Параметр `value` в кажом из полей по прежнему
     * должен соответствовать `code` из опции, а не подержать полный объект опции.
     */
    useFullItem?: UseFullItem;
    /**
     * Если при переключении на следующий шаг или при загрузки опций шага будет получен единственный вариант для выбора,
     * он будет автоматически выбран и будет осуществлён стандартный переход к следующему шагу.
     * Не применяется для `creatable` полей, по понятным причинам.
     */
    autoSelectSingleItem?: UseFullItem;
    /**
     * Сообщение об ошибке, при проблемах с загрузкой опций.
     * Здесь работает глобально для всех полей, у которых не указан статичный набор опций,
     * также можно для каждого `field` указать отдельное сообщение.
     */
    optionsLoadingErrorMessage?: string;
    /**
     * Обработчик асинхронной загрузки опций для поля.
     * Принимает весь массив полей `fields` и информацию о текущем поле
     * и должен возвращать `Promise` с массивом `items`, сформированным в зависимости от ранее заполненных
     * значений в `fields`.
     * Логика запросов реализуется на стороне приложения.
     */
    loadOptions?: (allFields: CombinedSelectField[], currentField: CombinedSelectField) => Promise<CombinedItem[] | void>;
    /**
     * Обработчик изменения значения. Вызывается для каждого из полей.
     * ВНИМАНИЕ! При удалении значения поля, если последующие значения также от него зависят,
     * необходимо удалять их на стороне приложения.
     */
    onChange?: (field: CombinedSelectField, newValue: OnChangeValue<UseFullItem> | null) => Promise<void> | void;
    /**
     * Обработчик события начала редактирования значения.
     * Вызывается перед началом обработки изменений для каждого из полей.
     */
    onEditStart?: (field: CombinedSelectField) => Promise<void> | void;
    /**
     * Обработчик события завершения редактирования значения.
     * Вызывается после завершения обработки изменений для каждого из полей.
     */
    onEditEnd?: (field: CombinedSelectField) => Promise<void> | void;
    /**
     * Обработчик фокуса в контрол.
     * Вызывается при фокусе по инициативе пользователя, а также при смене активного поля,
     * так как переключение полей при выборе блюрит и фокусирует контрол автоматически.
     */
    onControlFocus?: (props: CombinedSelectProps<UseFullItem>) => void;
    /**
     * Обработчик потери фокуса контрола.
     * Вызывается при потере фокуса по инициативе пользователя, а также при смене активного поля,
     * так как переключение полей при выборе блюрит и фокусирует контрол автоматически.
     */
    onControlBlur?: (props: CombinedSelectProps<UseFullItem>) => void;
}
export declare const defaultCombinedSelectProps: {
    autoSelectSingleItem: boolean;
    useFullItem: boolean;
    optionsLoadingErrorMessage: string;
    disabled: boolean;
    locked: boolean;
    hidden: boolean;
    showTooltip: boolean;
    size: import("../BaseControlWrapper/styled/ControlBox").ControlBoxSize;
    scrollTopOffset: number;
};
export declare type CombinedSelect = <UseFullItem extends boolean = false>(props: CombinedSelectProps<UseFullItem>) => ReactElement;
declare const _default: CombinedSelect;
export default _default;
