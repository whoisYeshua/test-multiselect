import { ReactElement } from 'react';
import { ExternalControlWrapperProps } from '../BaseControlWrapper/ControlWrapper';
import { DateFormat } from './types';
export interface RangeValue {
    startDate: string;
    endDate: string;
}
declare type DatepickerChangeValue<T extends boolean> = T extends true ? RangeValue : string;
export declare enum MonthSelectorVariant {
    DROPDOWN = "dropdown",
    ARROWS = "arrows"
}
export declare type MonthSelectorVariantType = `${MonthSelectorVariant}`;
export interface DatepickerProps<IsRange extends boolean = false> extends Omit<ExternalControlWrapperProps, 'caption'> {
    /**
     * Регулирует формат даты которая будет возвращена в методе onChange. В ISO формате таймзона будет проигнорирована.
     */
    dateFormat?: DateFormat;
    /**
     * Выбранная дата в формате ДД.ММ.ГГГГ или ISO (для режима выбора одной даты).
     */
    value?: string | null;
    /**
     * Начальная дата в формате ДД.ММ.ГГГГ или ISO (для режима range).
     */
    startDate?: string | null;
    /**
     * Конечная дата в формате ДД.ММ.ГГГГ или ISO (для режима range).
     */
    endDate?: string | null;
    /**
     * Число которое будет вычитаться из текущего года для получения минимального для выбора года.
     */
    numberOfYearsAgo?: number;
    /**
     * Число которое будет складываться с текущим годом для получения максимального для выбора года.
     */
    numberOfYearsAhead?: number;
    /**
     * Переключение в режим выбора диапазона дат, вместо одной даты (DatepickerRange)
     */
    isRange?: IsRange;
    /**
     * Для режима `isRange`.
     * Вызывает событие `onChange` не по факту выбора полного периода, а на каждую из дат.
     * Необходимо учитывать, что объект `RangeValue` при этом может быть не полным.
     */
    handleEveryDate?: boolean;
    /**
     * Недоступные для выбора даты. Можно передать массив конкретных дат в формате ДД.ММ.ГГГГ или ISO -
     * тогда недоступны будут только указанные даты.
     */
    disabledDates?: string[];
    /**
     * Самая ранняя дата из доступных для выбора. Передаётся в формате ДД.ММ.ГГГГ или ISO.
     * В совокупности с `maxDate` позволяет ограничить диапазон выбора дат.
     * Если `maxDate` не указан, то выбор ограничивается только "снизу".
     */
    minDate?: string;
    /**
     * Самая поздняя дата из доступных для выбора. Передаётся в формате ДД.ММ.ГГГГ или ISO.
     * В совокупности с `minDate` позволяет ограничить диапазон выбора дат.
     * Если `minDate` не указан, то выбор ограничивается только "сверху".
     */
    maxDate?: string;
    /**
     * Можно ли очистить выбранное значение
     */
    clearable?: boolean;
    /**
     * Отображаемое название контрола.
     */
    caption: string;
    /**
     * Позволяет указать кастомный текст сообщения о вводе некорректной или недоступной для выбора даты.
     * Для одиночного режима.
     * Валидация на такие даты работает внутри контрола.
     * Срабатывает только при вводе даты с клавиатуры,
     * так как календарь и так не позволяет выбрать запрещённые даты.
     */
    incorrectSingleDateMessage?: string;
    /**
     * Позволяет указать кастомный текст сообщения о вводе некорректной или недоступной для выбора начальной даты.
     * Для режима `range`.
     * Валидация на такие даты работает внутри контрола.
     * Срабатывает только при вводе даты с клавиатуры,
     * так как календарь и так не позволяет выбрать запрещённые даты.
     */
    incorrectStartDateMessage?: string;
    /**
     * Позволяет указать кастомный текст сообщения о вводе некорректной или недоступной для выбора конечной даты.
     * Для режима `range`.
     * Валидация на такие даты работает внутри контрола.
     * Срабатывает только при вводе даты с клавиатуры,
     * так как календарь и так не позволяет выбрать запрещённые даты.
     */
    incorrectEndDateMessage?: string;
    /**
     * Позволяет указать кастомный текст сообщения о вводе некорректного интервала.
     * Для режима `range`.
     * Срабатывает в ситуациях, если начальная дата интервала позже конечной или если интервал содержит
     * запрещённые для выбора даты.
     * Валидация на такие даты работает внутри контрола.
     * Срабатывает только при вводе даты с клавиатуры,
     * так как календарь и так не позволяет выбрать запрещённые даты.
     */
    incorrectRangeMessage?: string;
    /**
     * Позволяет открывать календарь только при клике на иконку.
     * По умолчанию календарь отображается по клику на контрол.
     */
    showCalendarOnlyOnIconClick?: boolean;
    /**
     * Вариант внешнего вида селектора месяцев в календаре.
     */
    monthSelectorVariant?: MonthSelectorVariantType;
    /**
     * Если параметр активен, никакие ошибки валидации внутри контрола не будут отображаться.
     * "Неправильное" значение всё равно передаётся в `onChange`, так что это позволит применять валидацию
     * только на стороне приложения, например по сабмиту формы.
     */
    hideDefaultErrors?: boolean;
    /**
     * Обработчик изменений значения.
     */
    onChange?: (props: DatepickerProps<IsRange>, newValue: DatepickerChangeValue<IsRange>) => Promise<void> | void;
    /**
     * Обработчик события начала редактирования значения. Вызывается по фокусу.
     */
    onEditStart?: (props: DatepickerProps<IsRange>) => Promise<void> | void;
    /**
     * Обработчик события завершения редактирования значения. Вызывается после потери фокуса.
     */
    onEditEnd?: (props: DatepickerProps<IsRange>) => Promise<void> | void;
}
export declare const defaultDatepickerProps: DatepickerProps<false>;
export declare type DatepickerType = <IsRange extends boolean = false>(props: DatepickerProps<IsRange>) => ReactElement;
declare const _default: DatepickerType;
export default _default;
