# ui-design-system

Библиотека компонентов, общая для всех веб-сервисов Ренессанс.

## Подготовка к работе

1. Необходима установленная Node.js LTS версии. Узнать текущую версию на своей машине `node -v`, при необходимости [установить](https://nodejs.org/en/download/)
2. Установить все зависимости `npm ci`

## Работа в VSCode

Рекомендуемые расширения:

-   [Prettier](https://marketplace.visualstudio.com/items?itemName=esbenp.prettier-vscode)
-   [ESLint](https://marketplace.visualstudio.com/items?itemName=dbaeumer.vscode-eslint)

## Использование

Для доступа к пакету, в проекте необходим файл конфигурации `.npmrc`, содержащий:

```bash
strict-ssl=false
registry=https://nexus.renins.com/repository/npm-proxy/
@ui:registry=https://nexus.renins.com/repository/npm-iris-ui/
```

Установка пакета с зависимостями - `npm install @ui/design-system @ui/screen-size-provider --save`

Импорт необходимого компонента происходит только следующим образом:

```bash
import Button from '@ui-design-system/accessories/Button';
import Input from '@ui-design-system/controls/Input';
```

Импорт компонента иконки происходит по имени:

```bash
    import Archive from '@ui/design-system/icons/Archive';
```

Данное требование необходимо для уменьшения бандла библиотеки.

## Сторибук

В сторибуке можно увидеть все состояния компонентов и примеры, как ими пользоваться. Документация по пропсам и примеры кода находятся на вкладке "Docs".

Сторибук можно поднять локально:

```bash
    npm run storybook
```

Или посетить стенд [документации](http://storybook.k8s.renins.com/)

Сборка сторибука для деплоя:

```bash
    npm run build-storybook
```

## Разработка

Запуск приложения для разработки осуществляется командой

```bash
    npm start
```

Входная точка для поднятия приложение служит `src/index.tsx`, в этот файл необходимо импортировать разрабатывамый компонент.

Девсборка с sourcemaps:

```bash
    npm run build:dev
```

При необходимости, протестировать изменения на каком-либо "зависимом" проекте можно одним из следующих способов:

-   выполнить команду `build` библиотеки, а затем вручную добавить все результаты билда в `node_modules/@ui/design-system` "зависимого" проекта, удалив перед этим оттуда все старые файлы билда.

-   собрать пакет с бета версией ( например бету фикса - `1.0.1-beta.1`), опубликовать ее `npm run publish:beta`, затем установить в "зависимом" приложении `npm i @ui/design-system@beta`.

## Правила создания коммита

-   Так как сообщение коммита будет отображаться в CHANGELOG нужно писать что было сделано, а не то что сделали вы.
-   Пример: В компонент `Button` добавлен параметр `autoWidth`.

1. Коммиты ДОЛЖНЫ начинаться с префикса, который содержит существительное ['build', 'chore', 'ci', 'docs', 'feat', 'fix', 'perf', 'refactor',
   'revert', 'style', 'test'], за которым следует двоеточие и пробел.

2. Тип feat ДОЛЖЕН использоваться для коммитов, которые добавляют новую функциональность в ваше приложение или библиотеку.

3. Тип fix ДОЛЖЕН использоваться для коммитов, которые исправляют баги в вашем приложении или библиотеки.

4. НЕ ОБЯЗАТЕЛЬНАЯ область (scope) МОЖЕТ быть указана после типа. Область - это фраза, описывающая контекст кодовой базы, измененной коммитом, заключенная в круглые скобки. Например, fix(parser):.

5. Краткое описания ДОЛЖНО следовать сразу же после указания префикса типа/области. Краткое описание - это сжатое описание изменения кода, которое несет в себе коммит, например, fix: array parsing issue when multiple spaces were contained in string.

6. Описание нарушения обратной совместимости ДОЛЖНО следовать сразу же после BREAKING CHANGE: . Оно должно разъяснять, что изменилось в API. Например, BREAKING CHANGE: environment variables now take precedence over config files.

7. Типы отличные от feat и fix МОГУТ использоваться в сообщениях коммитов.

-   Пример: git commit -m "feat: сообщение"

## Создание новых компонентов

-   При создании новых компонентов необходимо придерживаться существующей структуры экспортов:
    -   у каждого компонента свой `index.ts` для экспорта;
    -   при экспорте компонента с `withScreen` из провайдера экрана, нужно дописывать ему `displayName`, чтобы он нормально отображался в девтулзах и документации сторибука;

1. Создать директорию для коллекции новых компонента в `src` или компонент в существующей директории.

2. В `webpack.entries.js` прописать путь к новому компоненту.

3. На новый компонент необходимо написать тест.

4. На новый компонент написать сториз.

5. Если была создана директория для коллекции новых компонентов, то прописать ее в `package.json` в `files`.

## Работа с иконками

-   Могут возникнуть случаи, когда необходимо будет пересобрать иконки, т.е из большого количества свг сделать большое количество React компонентов.
    Для таких случаев есть специальные скрипты. Но если необходимо добавить только несколько иконок, то целесообразней будет это сделать руками, так как
    данные скрипты пересобирают все иконки. Также есть компоненты иконок, в которые вносились специальные изменения, их нельзя пересобирать, изменения вносить только руками, иначе сломаются
    некоторые компоненты библиотеки. Список таких компонентов: TipRound, CheckboxTick.

Шаги по массовой пересборке иконок:

1. Обновить иконки в директории `icon_helpers/assets`

2. ```bash
       npm run build-icons
   ```

## Внесение изменений

1. Создать от ветки dev новую feature-ветку c названием задачи. (Пример: feature/IRIS-9549)
2. Во время разработки и тестирования фичи или исправления, при необходимости, можно публиковать бета-версии, для того, чтобы проверить работу в рамках реального приложения:

**Например: 2.0.0-beta.1 (major), 1.7.0-beta.3 (minor), 1.6.8-beta.2 (patch). При необходимости перепубликации в рамках одного и того же изменения (версии), например при фиксе ошибок выявленных на тестировании, повышается beta версия - beta.1, beta.2 и т.д И так до момента релиза "полноценной"**

3. Изменение версии до "беты" и в рамках повышения беты делать **ТОЛЬКО** при помощи изменения файла `package.json` руками. **НЕ** использовать команды вида `npm version 8.8.3-beta.1`, так как это создаст лишние теги в репозитории.
4. Поднятие версии до беты делается также по согласованию о версионировании, т.е. если текущая версия `8.8.2`, а вносимые изменения считаются **минорными**, новая бета-версия должна быть `8.9.0-beta.1`. Аналогичное правило применяется и для патчей и для мажорных изменений.

**ВАЖНО! Изменённый руками номер версии НЕ должен попасть в коммит по задаче, так как это изменение делается только для публикации беты с ЛОКАЛЬНОЙ машины**

5. После того, как номер версии скорректирован, пакет необходимо опубликовать с соответствующим `beta` тегом:

```bash
    npm run publish:beta
```

6. Закоммитить измененные файлы, создать МР, при этом **НЕ** обязательно коммитить каждое изменение в рамках тестирования, так как бета-версии публикуются с локальной машины. Достаточно, чтобы в репозиторий попал финальный результат и строго с исходным номером версии, чтобы это не повлияло на релизную версию из `dev` ветки после мержа задачи.
7. Передать на ревью в команду фронта.
8. После прохождения ревью, и, при необходимости, тестирования на `beta` версиях, смержить свои изменения в `dev` ветку репозитория `ui-design-system`.

## Публикация пакетов для nmp версии 7+

Начиная с 7 версии `npm`, публикация без авторизации в корпоративном репозитории пакетов ([nexus](https://nexus.renins.com/#browse/browse:npm-iris-ui)) стала невозможной. Если у вас нет учетной записи с соответствующими правами доступа, то, возможно, публикация вам и ни к чему и лучше обратиться к уполномоченным лицам :). Если же учётная запись имеется, то необходимо добавить токен авторизации в глобальный конфиг `npm`

```bash
    npm config set -g //nexus.renins.com/repository/npm-iris-ui/:_auth <token>
```

В примере выше, `token` - это base64 комбинации `login:password`, можно получить в консоли браузера командой

```bash
    btoa('login:password');
```

После успешного обновления конфига, публикация становится доступной также как и в "обычном" режиме.

Также следует обратить внимание, что для доступа к Nexus обычно используется общая учётная запись - ей просто выдают дополнительные права доступа, посему, в связи с требованием о регулярной смене пароля, конфиг также необходимо будет обновлять после каждого обновления пароля в общей учётной записи.

## Публикация релиза

1. **ОБЯЗАТЕЛЬНО** убедиться, что ваши изменения стоят того, чтобы немедленно быть опубликованными. В ряде случаев целесообразнее публиковать более крупный релиз, сразу с множеством изменений, чем выпускать новую версию для каждого мелкого исправления. Посему, перед публикацией необходимо согласовать её целесообразность с командой фронта.
2. Проверить, какие версии уже опубликованы

```bash
    npm view @ui/design-system versions --json
```

3. Поднять версию пакета **строго из ветки develop** при помощи команды с учётом соглашения о версионировании (major.minor.patch) [подробнее](https://semver.org/), запушить изменение версии в гит, **обязательно** вместе с тегами.

```bash
    npm run release -- --release-as <версия>
    git push origin develop
    git push origin --tags
```

Подробнее о [npm version](https://docs.npmjs.com/cli/version)

-   `major` - если внесенные изменения приводят к отсутствию обратной совместимости с предыдущей версией. Например `1.3.1` -> `2.0.0`
-   `minor` - изменения добавляют новую функциональность и не нарушают обратную совместимость. Например `1.3.1` -> `1.4.0`
-   `patch` - изменения исправляют баги в текущей версии и не нарушают обратную совместимость. Например `1.3.1` -> `1.3.2`

4. Опубликовать новую версию пакета при помощи команды `npm publish`. (сборка билда запустится автоматически на npm хук `prepublishOnly`).
5. После публикации пакета `@ui/design-system`, поднять его версию в клиентском приложении и убедиться, что в файле package-lock.json данные о версии также обновились

```bash
    npm install @ui/design-system@x.x.x //где x.x.x версия пакета в виде major.minor.patch
```

## Тестирование

-   Запуск всех тестов для быстрого локального прогона (например на prepush хук). Пока в проекте реализована поддержка только юнит-тестирования (снепшотов).
    ```bash
    npm test
    ```

### Юнит-тесты

Для юнит-тестирования используются [Jest](https://jestjs.io/en/) и [Enzyme](https://enzymejs.github.io/enzyme/).

```bash
   npm test
```

## Линтинг

-   Запуск ESLint

```bash
   npm run lint
```

-   Запуск Prettier

```bash
    npm run prettier
```
